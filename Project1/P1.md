
Project 1: Hello, bitshifting!


- Getting C, GCC set up and compiling code

Phase 0. Prologue:

I can't really assume absolutely zero exposure to programming without this
series being twice as long, but we'll try to start with the most digestible
steps possible. I'll assume that you at least know roughly what datatypes
are, what functions are, and how they receive and return data at a basic
conceptual level. I will still give a short crash course to C syntax, though.

C is written like pretty much any other imperative (lines of code are executed
one after another) programming language. It posseses:

* Fundamental types

The fundamental types typically used in C are `char`, `int`, `float`, and
`double`. The first two types are integers (whole numbers, e.g. 3, -1, 12), and
the last two types are floating point decimals (real numbers, e.g. 2.143,
0.000003, 3.1415926). The distinction between `char` and `int` or `float` and
`double` are how much memory each takes up; later on we will take a deep dive
into what this actually means when it comes to programming.

* Variables

```c
int a = 3;
```

Where `int` tells the compiler what type of data the variable holds, and 3 is
the value assigned to the variable.

* Arithmetic

```c
int a = 3;
int b = 2;

int c;  // declaring 'c' without giving it a value
c = a + b;  // c is now 5
c = a * b;  // c is now 6
c = a / b;  // c is now 1 (note: integer division)
c = a % b;  // c is now 1 (modulo operator)
```

With integers, `a / b` represents integer division, i.e. long division.
3 divided by 2 is 1 (3 goes into 2 once) with a remainder of 1. a % b performs
the same division but returns the remainder instead of the quotient.

We also have versions of the arithmetic operators which compact a special
statement:

```c
int a = a + 5;  // Add 5 to a

// Can be equivalently written:

int a += 5;
```

The same thing exists for `-=`, `*=`, `/=`, and so on.

* Boolean logic

```c
int a = 1;
int b = 3;
int c;

if (a < b)
{
    c = 0;

}
else if (a == b)
{
    c = 1;
}
else  // a isn't < b or == b, so it must be > b
{
    c = 2;
}

// c will be 0 since a (1) is less than b(3)

```

Note that to test for equality, double equals (`==`) is used. Single `=` is
for setting the left side to the value of the right side, and double `==` is
used to test if the left and right side have the same value.

Integers themselves can be interpreted as boolean values (C does not possess a
pure `bool` type):

```c
int a = 0;
int b = 1;
int c;

if (!a)
{
    c = 5;
}

// c == 5 since !a (not)(0; false) is true, so c is set

if (b)
{
    c = 6;
}

// c is now overwritten with 6 since b (1) evaluates to true
```

* Functions

```c
int add(int a, int b)
{
    return a + b;
}
```

This function takes two integers, `a` and `b`, and returns their sum (an int).

Functions return values like in any other language:

```c
int a = 3;
int b = 2;

int c = add(a, b);  // c == 5
int d = add(5, 1);  // d == 6
```

Void returns:

```c
void print_value(int c)
{
    printf("Here's my int: %d", c);
}
```

This function takes an integer and has a `void` return (i.e. it returns
nothing). Don't worry about the `printf()` function yet, it just prints out
its argument; we needed something for the function to do that doesn't depend
on returning a value, and this is the simplest example.

* Arrays

Like any other language, collections of data can be stored in arrays, which are
fixed-length, fixed-order lists of data:

```c
int my_array[5];  // Creates an uninitialized array of 5 integers

my_array[0] = 1;  // Array indices start at 0
my_array[1] = 2;
my_array[2] = 3;
my_array[3] = 4;
my_array[4] = 5;
```

We can loop over this array with a **for loop**:

```c
for (int i = 0; i < 5; i++)
{
    my_array[i] += 2;
}

// my_array now contains {3, 4, 5, 6, 7}
```

`i++` is shorthand for `i = i + 1` or `i += 1`.

Another type of loop, the **while loop** behaves like an "if" statement
that repeats as long as the argument remains true:

```c
int i = 0;
int a = 0;
int k = 10;
while (i < k)
{
    a += 1;
    i++;
}

// a is now 10
```

Phase I. Hello World!

Here is the canonical starting point of setting up any new language. I will
provide the code in full. Type it (do not copy and paste) into a new file:

```c
#include <stdio.h>

int main(void)
{
    printf("Hello, world!\n");
    return 0;
}

```

`#include <stdio.h>` is a **preprocessor directive** which essentially tell
the compiler "Hey, before you go about compiling this code, there are some
things that this program contains that we haven't defined ourselves. In this
case, `printf()` is an external function (we haven't defined it here, nor is
it a fundamental, primitive feature of C like arithmetic), which is defined
in the file `stdio.h` (**st**and**d**ard **I/O**).

Our `main()` function takes no arguments (void) and returns an int. This return
value typically represents whether or not the program worked correctly;
returning 0 indicates that everything went fine, returning anything else means
there was some sort of error. We return 0 because if we made it to the end of
our `main()` function, nothing catastrophic happened (the program didn't stop
or die halfway through).

Save your file under the name `hello.c` in the Project1 folder. While in the
same folder, type the following commands:

```bash
you@computer:~/Path/to/Project1$ gcc hello.c
```

The current directory should now contain a file called `a.out`, which is the
output of the compiler, your compiled executable. Type:

```bash
you@computer:~/Path/to/Project1$ ./a.out
```

to run the program. You should be greeted by the message:

```bash
you@computer:~/Path/to/Project1$ ./a.out
Hello, world!
you@computer:~/Path/to/Project1$ 
```

If so, everything worked! If not, google is your best friend. Any errors
encountered this early as surely incredibly common with anyone starting to
learn C so answers should be readily available online.

Phase II. Strings are arrays

- Write a string and then index its elements like an array

Now that we have a functional basis for writing code, we'll focus on an
application of the basic features of C.

Strings (strings of letter, i.e. text) are a common object to work with in most
languages, and C is no exception. In C, however, the interaction with strings
is lower level than in most languages.

Strings are fundamentally represented by arrays of characters, which seems
logical enough. We can represent the phrase "Hello, world!" as a list that
contains its constituent characters:

```
{'H', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd', '!', '\0'}
```

Note the last character in the list, `\0`. This is the "null" character,
which is simply a byte containing the number 0, `0000 0000`. This character
is how the computer knows it has hit the end of the string, and we say that
strings in C are **null terminated**.

Now it's time to take a very significant detour and talk about binary
representations of data. It may seem heavy handed and advanced, and some
would argue that it's too early to dive into, but it provides a fundamental
understanding of what the computer is doing that is extremely powerful when
it comes to learning the more confusing aspects of programming like pointers
(next project).

###Binary and Hex

Let's return to our friends `int` and `char`.

`char` is often used to represent ASCII characters, which are defined to be 
represented by 1 byte (8 bits). I suggest looking up an ASCII table online,
to see for yourself. For example, the lowercase letter 'a' is represented by
the ASCII value 97. Therefore, `char` is really just equivalent to a 1-byte
integer, with a maximum value of 2^8 or 255 (plus 0, for a total of 256). It
behaves like a character when we interpret it as such, but fundamentally it's
just a number.

`int` is also just an integer number, and almost always takes up 4-bytes, for
a maximum value of 2^32 or 4294967296.
Note that these max values are for **unsigned** integers, meaning they run from
0 to their maximum value. `int`s are signed by default, meaning their maximum
value is halved, because the most significant place is used as a sign bit.

To make sense of all this, I'm about to start writing values in binary and
hexadecimal.

Ordinary "decimal" (deci-: 10) values are stored as powers of 10:

6219 = 6\*10^3 + 2\*10^2 + 1\*10^1 + 9\*10^0

Similarly, binary values (base 2) are stored as powers of 2:

152 = 1\*2^7 + 0\*2^6 + 0\*2^5 + 1\*2^4  + 1\*2^3  + 0\*2^2  + 0\*2^1  + 0\*2^0 

So in binary we'd write it as 10011000. Not the most compact or intuitive way
for us to write numbers (since it takes many more digits and we are used to
having 10 fingers), but computers are built with binary switches so our
entire system hinges on binary representations.

Hexadecimal (base 16) is a conveient way to handle binary that is also not as
intuitive to use as base 10, but is far more compact. Instead of 10 digits, hex
has 16, so we count in hexadecimal like this:

0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F, 10, 11, ... 1A, 1B, 1C, 1D, 1E,
1F, ... 99, 9A, 9B, 9C, 9D, 9E, 9F, A0, A1, ... F9, FA, FB, FC, FD, FE, FF, 100

Here are some common hexadecimal numbers and their decimal equivalents:

| hex | decimal |
|-----|---------|
| 0   | 0       |
| 1   | 1       |
| 9   | 9       |
| A   | 10      |
| F   | 15      |
| 10  | 16      |
| 100 | 256     |
| 1000| 4096    |

The reason why hexadecimal is so useful is that one hex digit (0-F) can count
from 0 to 15, representing a total of 16 values. In binary, `1111` is 15 (`F` in
hex), and 16 (10 in hex) is `0001 0000`. `0010 0000` is 32 (20 in hex). Look at
how these values line up:

hex:    0 F
bin: 0000 1111

hex:    1 0
bin: 0001 0000

hex:    2 0
bin: 0010 0000

This is why I separate bytes into two groups of four: each group of four bits
is represented by one hex digit, which is a very handy correspondance. For
example, if I see the hexadecimal value 0xA04F3CC1 (`0x` simply means that it's
a hex number), I can immediately know that the binary representation is:

0x    A    0    4    F    3    C    C    1
bx 1010 0000 0100 1111 0011 1100 1100 0001

Unlike decimal, you can look at a hex number and know exactly how many bytes
it takes to store it, since two hex digits (e.g. `A0`, `4F`, `3C`, `C1`)
represents one byte.

So if we want 32 bits of all 1s, we can just write 0xFFFFFFFF, and know that
each group of 4 bits will be `1111`, and there are 8 digits, which corresponds
to 4 bytes.

If we want 64 bits of all zeroes, except we want the most significant byte to be
all 1s, we can write `0xFF 00 00 00 00 00 00 00` (when you write hex values
in code you can't separate them, but I've done it here to make the individual
bytes more obvious).

So returning to our datatypes, here are a few examples of `char`s and `int`s:

```
char a = 0;  // 0000 0000 = 0x0
char b = 1;  // 0000 0001 = 0x1
char c = 2;  // 0000 0010 = 0x2
char d = 3;  // 0000 0011 = 0x3
char e = 16; // 0001 0000 = 0x10

int f = 1000; // 0000 0000  0000 0000  0000 0011  1110 1000 = 0x000002E8 = 0x2E8
```

Note that the `char`s are one byte long, and in this case the `int` is 4 bytes
long (32 bit).

Floating point values also have binary representations, but they're more obtuse
and not particularly relevant to using them.

###Phase III. Bit shifts

###Phase IV. Bitwise operations

I suggest using the android application "BitCalculator," but the built-in Windows
calculator has a "programming" mode with similar functionality, and equivalents
can be found for other operating systems as well.
